class Solution {
public:
    void dfs(int node, int color, vector<vector<int>>& graph, vector<int>& colors) {
        colors[node] = color;
        for (int nei = 0; nei < graph.size(); ++nei) {
            if (graph[node][nei] == 1 && colors[nei] == -1) {
                dfs(nei, color, graph, colors);
            }
        }
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int N = graph.size();
        vector<int> colors(N, -1);
        int color = 0;

        // 1. Color each component
        for (int i = 0; i < N; ++i) {
            if (colors[i] == -1) {
                dfs(i, color, graph, colors);
                ++color;
            }
        }

        // 2. Size of each component
        vector<int> size(color, 0);
        for (int c : colors) {
            size[c]++;
        }

        // 3. Count how many initial nodes are in each component
        vector<int> color_count(color, 0);
        for (int node : initial) {
            color_count[colors[node]]++;
        }

        // 4. Choose the node to remove
        int ans = -1;
        sort(initial.begin(), initial.end()); // To ensure we pick the smallest index in tie
        for (int node : initial) {
            int c = colors[node];
            if (color_count[c] == 1) { // Unique infected node in this component
                if (ans == -1 || size[c] > size[colors[ans]]) {
                    ans = node;
                }
            }
        }

        return ans == -1 ? initial[0] : ans;
    }
};